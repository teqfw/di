[{"data":1,"prerenderedAt":611},["Reactive",2],{"content-query-1DxZ1vYQk5":3},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":5,"title":7,"description":8,"body":9,"_type":606,"_id":607,"_source":608,"_file":609,"_extension":610},"/","",false,"@teqfw/di","A Dependency Injection container for regular JavaScript is provided, which can be used in both browser and Node.js\napplications. This library exclusively supports ES6 modules. The primary objective of this library is late binding with\nminimal manual configuration for the container. All linking instructions are encapsulated within the dependency\nidentifiers and source path resolver. Additionally, the container offers the capability to modify object identifiers\n(preprocessing) and the created objects (postprocessing). These features enable you to more comprehensively\ndistribute the necessary functionality across npm packages and reuse npm packages in different projects, following a '\nmodular monolith' architecture (see the sample).",{"type":10,"children":11,"toc":591},"root",[12,20,80,87,92,97,110,115,124,129,135,153,162,176,182,187,195,200,208,213,221,226,234,240,245,254,259,268,273,282,288,302,311,316,325,330,339,344,353,359,364,390,395,404,416,422,427,436,441,464,469,480,489,500,509,535,540,544,549,558,567,576,582],{"type":13,"tag":14,"props":15,"children":17},"element","h1",{"id":16},"teqfwdi",[18],{"type":19,"value":7},"text",{"type":13,"tag":21,"props":22,"children":23},"p",{},[24,26,32,34,39,41,46,48,53,55,60,62,67,69,78],{"type":19,"value":25},"A Dependency Injection container for regular JavaScript is provided, which can be used in both ",{"type":13,"tag":27,"props":28,"children":29},"em",{},[30],{"type":19,"value":31},"browser",{"type":19,"value":33}," and ",{"type":13,"tag":27,"props":35,"children":36},{},[37],{"type":19,"value":38},"Node.js",{"type":19,"value":40},"\napplications. This library exclusively supports ES6 modules. The primary objective of this library is late binding with\n",{"type":13,"tag":27,"props":42,"children":43},{},[44],{"type":19,"value":45},"minimal manual configuration",{"type":19,"value":47}," for the container. All linking instructions are encapsulated within the dependency\nidentifiers and source path resolver. Additionally, the container offers the capability to modify object identifiers\n(",{"type":13,"tag":27,"props":49,"children":50},{},[51],{"type":19,"value":52},"preprocessing",{"type":19,"value":54},") and the created objects (",{"type":13,"tag":27,"props":56,"children":57},{},[58],{"type":19,"value":59},"postprocessing",{"type":19,"value":61},"). These features enable you to more comprehensively\ndistribute the necessary functionality across npm packages and reuse npm packages in different projects, following a '\n",{"type":13,"tag":27,"props":63,"children":64},{},[65],{"type":19,"value":66},"modular monolith",{"type":19,"value":68},"' architecture (see the ",{"type":13,"tag":70,"props":71,"children":75},"a",{"href":72,"rel":73},"https://github.com/flancer64/demo-di-app",[74],"nofollow",[76],{"type":19,"value":77},"sample",{"type":19,"value":79},").",{"type":13,"tag":81,"props":82,"children":84},"h2",{"id":83},"inversion-of-control",[85],{"type":19,"value":86},"Inversion of Control",{"type":13,"tag":21,"props":88,"children":89},{},[90],{"type":19,"value":91},"The primary motivation for creating this library was the concept that JavaScript is a language in which the entire\napplication can be written, both on the front end and the back end. The idea was to enable the use of the same\nJavaScript code seamlessly on both the front end and the back end without requiring any changes, including additional\ntranspilation.",{"type":13,"tag":21,"props":93,"children":94},{},[95],{"type":19,"value":96},"The main challenge encountered along this path was static importing. When the entire application can fit into a single\nnpm package, all sources can be linked to each other through relative paths. However, if the sources are distributed\nacross different npm packages, addressing them becomes problematic:",{"type":13,"tag":98,"props":99,"children":104},"pre",{"code":100,"language":101,"meta":5,"className":102},"// backend style\nimport something from '@vendor/package/src/Module.js';\n\n// frontend style\nimport something from 'https://domain.com/@vendor/package/src/Module.js'; \n","javascript",[103],"language-javascript",[105],{"type":13,"tag":106,"props":107,"children":108},"code",{"__ignoreMap":5},[109],{"type":19,"value":100},{"type":13,"tag":21,"props":111,"children":112},{},[113],{"type":19,"value":114},"The inversion of control (IoC) design pattern came to the rescue. In this pattern, any software object with external\ndependencies provides a mechanism for obtaining these dependencies. The external environment, whether it's a test unit\nor an object container, is responsible for creating these dependencies and providing them to the software object.",{"type":13,"tag":98,"props":116,"children":119},{"code":117,"language":101,"meta":5,"className":118},"// constructor-based injection\nclass Service {\n  constructor(config, logger) {}\n}\n",[103],[120],{"type":13,"tag":106,"props":121,"children":122},{"__ignoreMap":5},[123],{"type":19,"value":117},{"type":13,"tag":21,"props":125,"children":126},{},[127],{"type":19,"value":128},"If all dependencies are added to software objects through a similar mechanism, there is no need to use static imports in\nthe source code itself. Now, they can be used without any changes, both on the front end and on the back end.",{"type":13,"tag":81,"props":130,"children":132},{"id":131},"object-container",[133],{"type":19,"value":134},"Object Container",{"type":13,"tag":21,"props":136,"children":137},{},[138,140,144,146,151],{"type":19,"value":139},"Many programming languages implement the Dependency Injection pattern. In this pattern, an application typically\nutilizes an object container, responsible for creating all the application's objects and their dependencies. The\n",{"type":13,"tag":106,"props":141,"children":142},{"className":5},[143],{"type":19,"value":7},{"type":19,"value":145}," package provides precisely such an object container (",{"type":13,"tag":106,"props":147,"children":148},{"className":5},[149],{"type":19,"value":150},"src/Container.js",{"type":19,"value":152},"). This object container is\ninitialized and configured at the outset of application execution, after which it assumes responsibility for creating\nthe remaining application objects:",{"type":13,"tag":98,"props":154,"children":157},{"code":155,"language":101,"meta":5,"className":156},"import Container from '@teqfw/di';\n\nconst container = new Container();\nconst resolver = container.getResolver();\nresolver.addNamespaceRoot('App_', pathApp);\nresolver.addNamespaceRoot('Sample_Lib_', pathLib);\nconst app = await container.get('App_Main$');\n",[103],[158],{"type":13,"tag":106,"props":159,"children":160},{"__ignoreMap":5},[161],{"type":19,"value":155},{"type":13,"tag":21,"props":163,"children":164},{},[165,167,174],{"type":19,"value":166},"Since JavaScript does not have its own namespaces, similar to packages in Java and namespaces in PHP, the experience of\n",{"type":13,"tag":70,"props":168,"children":171},{"href":169,"rel":170},"https://framework.zend.com/manual/2.4/en/migration/namespacing-old-classes.html",[74],[172],{"type":19,"value":173},"Zend 1",{"type":19,"value":175}," is used as the basis for\nidentifiers.",{"type":13,"tag":81,"props":177,"children":179},{"id":178},"namespaces",[180],{"type":19,"value":181},"Namespaces",{"type":13,"tag":21,"props":183,"children":184},{},[185],{"type":19,"value":186},"The primary purpose of namespaces is to address code elements within an application. In JavaScript (JS) applications,\ncode is organized into npm packages, within which the sources reside in files and directories. Each npm package and its\nroot directory can be linked to a namespace:",{"type":13,"tag":98,"props":188,"children":190},{"code":189},"Vendor_Package_ => /home/user/app/node_modules/@vendor/package/src/....\n",[191],{"type":13,"tag":106,"props":192,"children":193},{"__ignoreMap":5},[194],{"type":19,"value":189},{"type":13,"tag":21,"props":196,"children":197},{},[198],{"type":19,"value":199},"This way, you can reference any ES6 module in any npm package:",{"type":13,"tag":98,"props":201,"children":203},{"code":202},"Venodr_Package_Shared_Dto_Service_Save \n    => /home/user/app/node_modules/@vendor/package/src/Shared/Dto/Service/Save.js \n",[204],{"type":13,"tag":106,"props":205,"children":206},{"__ignoreMap":5},[207],{"type":19,"value":202},{"type":13,"tag":21,"props":209,"children":210},{},[211],{"type":19,"value":212},"Depending on the execution environment, the mapping may be different:",{"type":13,"tag":98,"props":214,"children":216},{"code":215},"Vendor_Package_ => /home/user/app/node_modules/@vendor/package/src    // Linux style\nVendor_Package_ => C:\\projects\\app\\node_modules\\@vendor\\package\\src   // Windows style\nVendor_Package_ => https://unpkg.com/@vendor/package/src              // Web style\n",[217],{"type":13,"tag":106,"props":218,"children":219},{"__ignoreMap":5},[220],{"type":19,"value":215},{"type":13,"tag":21,"props":222,"children":223},{},[224],{"type":19,"value":225},"The source code employs namespaces to reference dependencies, while the object container utilizes a resolver to\ntranslate the namespace into the corresponding path to the source code file, contingent upon the runtime environment:",{"type":13,"tag":98,"props":227,"children":229},{"code":228},"Venodr_Package_Shared_Dto_Service_Save \n    => /home/user/app/node_modules/@vendor/package/src/Shared/Dto/Service/Save.js\nVenodr_Package_Shared_Dto_Service_Save \n    => C:\\projects\\app\\node_modules\\@vendor\\package\\src\\Shared\\Dto\\Service\\Save.js\nVenodr_Package_Shared_Dto_Service_Save \n    => https://unpkg.com/@vendor/package/src/Shared/Dto/Service/Save.js\n",[230],{"type":13,"tag":106,"props":231,"children":232},{"__ignoreMap":5},[233],{"type":19,"value":228},{"type":13,"tag":81,"props":235,"children":237},{"id":236},"dependency-specification",[238],{"type":19,"value":239},"Dependency Specification",{"type":13,"tag":21,"props":241,"children":242},{},[243],{"type":19,"value":244},"JavaScript lacks reflection capabilities similar to Java or PHP. Consequently, to enable the object container to\ncomprehend the necessary dependencies for creating a specific object, a distinct convention is employed - a dependency\nspecification. A dependency specification is an object where each key represents the identifier of the required\ndependency:",{"type":13,"tag":98,"props":246,"children":249},{"code":247,"language":101,"meta":5,"className":248},"class Service {\n  constructor(\n          {\n            App_Config: config,\n            App_Logger: logger\n          }\n  ) {}\n}\n",[103],[250],{"type":13,"tag":106,"props":251,"children":252},{"__ignoreMap":5},[253],{"type":19,"value":247},{"type":13,"tag":21,"props":255,"children":256},{},[257],{"type":19,"value":258},"In the object container, the required object is created as follows:",{"type":13,"tag":98,"props":260,"children":263},{"code":261,"language":101,"meta":5,"className":262},"const App_Config = await container.get('App_Config');\nconst App_Logger = await container.get('App_Logger');\nconst spec = {App_Config, App_Logger};\nconst obj = new Service(spec);\n",[103],[264],{"type":13,"tag":106,"props":265,"children":266},{"__ignoreMap":5},[267],{"type":19,"value":261},{"type":13,"tag":21,"props":269,"children":270},{},[271],{"type":19,"value":272},"If dependencies are injected into a factory function, it appears as follows:",{"type":13,"tag":98,"props":274,"children":277},{"code":275,"language":101,"meta":5,"className":276},"function Factory({App_Config: config, App_Logger: logger}) {\n  // perform operations with dependencies and compose the result\n  return res;\n}\n",[103],[278],{"type":13,"tag":106,"props":279,"children":280},{"__ignoreMap":5},[281],{"type":19,"value":275},{"type":13,"tag":81,"props":283,"children":285},{"id":284},"es6-export",[286],{"type":19,"value":287},"Es6 export",{"type":13,"tag":21,"props":289,"children":290},{},[291,293,300],{"type":19,"value":292},"In ES6+, a distinct building block in application development is the act\nof ",{"type":13,"tag":70,"props":294,"children":297},{"href":295,"rel":296},"https://flancer32.com/es6-export-as-code-brick-b33a8efb3510",[74],[298],{"type":19,"value":299},"exporting",{"type":19,"value":301},":",{"type":13,"tag":98,"props":303,"children":306},{"code":304,"language":101,"meta":5,"className":305},"export {\n  obj1 as default, obj2, obj3\n};\n",[103],[307],{"type":13,"tag":106,"props":308,"children":309},{"__ignoreMap":5},[310],{"type":19,"value":304},{"type":13,"tag":21,"props":312,"children":313},{},[314],{"type":19,"value":315},"Static linking through imports is performed at the level of these building blocks:",{"type":13,"tag":98,"props":317,"children":320},{"code":318,"language":101,"meta":5,"className":319},"import obj1 from './mod.js';\nimport {obj2} from './mod.js';\n",[103],[321],{"type":13,"tag":106,"props":322,"children":323},{"__ignoreMap":5},[324],{"type":19,"value":318},{"type":13,"tag":21,"props":326,"children":327},{},[328],{"type":19,"value":329},"This implies that the dependency identifier must have the capability to reference not only the ES6 module itself but\nalso a specific export within it, as illustrated in this example:",{"type":13,"tag":98,"props":331,"children":334},{"code":332,"language":101,"meta":5,"className":333},"const exp = 'Vendor_Package_Module.export';\nconst def = 'Vendor_Package_Module.default';\nconst obj2 = 'Vendor_Package_Module.obj2';\n",[103],[335],{"type":13,"tag":106,"props":336,"children":337},{"__ignoreMap":5},[338],{"type":19,"value":332},{"type":13,"tag":21,"props":340,"children":341},{},[342],{"type":19,"value":343},"In this case, the dependency declaration in a constructor or factory function could look like this:",{"type":13,"tag":98,"props":345,"children":348},{"code":346,"language":101,"meta":5,"className":347},"class Service {\n  constructor(\n          {\n            'App_Config.default': config,\n            'App_Util.logger': logger\n          }\n  ) {}\n}\n",[103],[349],{"type":13,"tag":106,"props":350,"children":351},{"__ignoreMap":5},[352],{"type":19,"value":346},{"type":13,"tag":81,"props":354,"children":356},{"id":355},"late-binding",[357],{"type":19,"value":358},"Late binding",{"type":13,"tag":21,"props":360,"children":361},{},[362],{"type":19,"value":363},"The object container links objects not at the source code level but in runtime mode. In my applications, I have\nencountered two particularly useful runtime object lifecycles:",{"type":13,"tag":365,"props":366,"children":367},"ul",{},[368,380],{"type":13,"tag":369,"props":370,"children":371},"li",{},[372,378],{"type":13,"tag":373,"props":374,"children":375},"strong",{},[376],{"type":19,"value":377},"Singleton",{"type":19,"value":379},": It exists in a single instance within the application.",{"type":13,"tag":369,"props":381,"children":382},{},[383,388],{"type":13,"tag":373,"props":384,"children":385},{},[386],{"type":19,"value":387},"Instance",{"type":19,"value":389},": A new object is created each time.",{"type":13,"tag":21,"props":391,"children":392},{},[393],{"type":19,"value":394},"Since any string can be used as an object key in a dependency specification, various formats can be devised to specify\nthe lifecycle of the required dependency. I have personally chosen the following format:",{"type":13,"tag":98,"props":396,"children":399},{"code":397,"language":101,"meta":5,"className":398},"const asIs = 'Vendor_Package_Module.default';\nconst asSingleton = 'Vendor_Package_Module.default$';\nconst asInstance = 'Vendor_Package_Module.default$$';\n",[103],[400],{"type":13,"tag":106,"props":401,"children":402},{"__ignoreMap":5},[403],{"type":19,"value":397},{"type":13,"tag":21,"props":405,"children":406},{},[407,409,414],{"type":19,"value":408},"In principle, each package can have its own format for describing the dependencies it uses internally. The\n",{"type":13,"tag":106,"props":410,"children":411},{"className":5},[412],{"type":19,"value":413},"TeqFw_Di_Container_Parser",{"type":19,"value":415}," object is responsible for applying the appropriate format within the required namespace.",{"type":13,"tag":81,"props":417,"children":419},{"id":418},"transforming-the-result",[420],{"type":19,"value":421},"Transforming the Result",{"type":13,"tag":21,"props":423,"children":424},{},[425],{"type":19,"value":426},"Here are the steps for the object container:",{"type":13,"tag":21,"props":428,"children":429},{},[430],{"type":13,"tag":431,"props":432,"children":435},"img",{"alt":433,"src":434},"processing steps","./doc/img/teqfw_di_container_steps.png",[],{"type":13,"tag":21,"props":437,"children":438},{},[439],{"type":19,"value":440},"There are two stages involved here:",{"type":13,"tag":365,"props":442,"children":443},{},[444,454],{"type":13,"tag":369,"props":445,"children":446},{},[447,452],{"type":13,"tag":373,"props":448,"children":449},{},[450],{"type":19,"value":451},"Preprocessing",{"type":19,"value":453},": the modification of the dependency identifier",{"type":13,"tag":369,"props":455,"children":456},{},[457,462],{"type":13,"tag":373,"props":458,"children":459},{},[460],{"type":19,"value":461},"Postprocessing",{"type":19,"value":463},": the modification of the created object",{"type":13,"tag":465,"props":466,"children":467},"h3",{"id":52},[468],{"type":19,"value":451},{"type":13,"tag":21,"props":470,"children":471},{},[472,474,478],{"type":19,"value":473},"At times, situations may arise, especially when utilizing various extensions of the core functionality, where it becomes\nnecessary to redefine certain objects within the application. For such scenarios, ",{"type":13,"tag":106,"props":475,"children":476},{"className":5},[477],{"type":19,"value":7},{"type":19,"value":479}," includes a preprocessor:",{"type":13,"tag":98,"props":481,"children":484},{"code":482,"language":101,"meta":5,"className":483},"/** @type {TeqFw_Di_Api_Container_PreProcessor} */\nconst pre = container.getPreProcessor();\n",[103],[485],{"type":13,"tag":106,"props":486,"children":487},{"__ignoreMap":5},[488],{"type":19,"value":482},{"type":13,"tag":21,"props":490,"children":491},{},[492,494,499],{"type":19,"value":493},"You can add handlers (chunks) to the preprocessor that are capable of modifying the initial ",{"type":13,"tag":106,"props":495,"children":496},{"className":5},[497],{"type":19,"value":498},"depId",{"type":19,"value":301},{"type":13,"tag":98,"props":501,"children":504},{"code":502,"language":101,"meta":5,"className":503},"/** @type {TeqFw_Di_Api_Container_PreProcessor_Chunk} */\nconst replace = new ReplaceChunk(); // some implementation of the interface\npre.addChunk(replace);\n",[103],[505],{"type":13,"tag":106,"props":506,"children":507},{"__ignoreMap":5},[508],{"type":19,"value":502},{"type":13,"tag":21,"props":510,"children":511},{},[512,514,519,521,526,528,533],{"type":19,"value":513},"The preprocessor calls the handlers sequentially and can, for example, replace a dependency from the base npm package\n(",{"type":13,"tag":106,"props":515,"children":516},{"className":5},[517],{"type":19,"value":518},"App_Base_Mod_Api_Service_Auth",{"type":19,"value":520},") with another dependency from one of the npm packages (",{"type":13,"tag":106,"props":522,"children":523},{"className":5},[524],{"type":19,"value":525},"Auth_Password_Mod_Service",{"type":19,"value":527}," or\n",{"type":13,"tag":106,"props":529,"children":530},{"className":5},[531],{"type":19,"value":532},"OAuth2_Mod_Service",{"type":19,"value":534},"), depending on the npm packages included in the application compilation.",{"type":13,"tag":21,"props":536,"children":537},{},[538],{"type":19,"value":539},"By using such replacements, you can implement the core functionality in one npm package, while in other npm packages,\nyou can implement the additional functionality required by the core package.",{"type":13,"tag":465,"props":541,"children":542},{"id":59},[543],{"type":19,"value":461},{"type":13,"tag":21,"props":545,"children":546},{},[547],{"type":19,"value":548},"Since the container creates all objects in the application, it can also perform additional actions on newly created\nobjects, such as adding extra functionality to them in the form of a wrapper.",{"type":13,"tag":21,"props":550,"children":551},{},[552,556],{"type":13,"tag":106,"props":553,"children":554},{"className":5},[555],{"type":19,"value":7},{"type":19,"value":557}," enables you to add individual handlers to the post-processing stage and modify the result. For example, you\ncan wrap a finished object or perform various operations on it:",{"type":13,"tag":98,"props":559,"children":562},{"code":560,"language":101,"meta":5,"className":561},"// ./PostChunk.js\n/**\n * @implements TeqFw_Di_Api_Container_PostProcessor_Chunk\n */\nexport default {\n    modify: function (obj, originalId, stack) {\n        if (originalId.wrappers.indexOf('proxy') !== -1)\n            return new Proxy(obj, {\n                get: async function (base, name) { /* do something */ }\n            });\n        else return obj;\n    }\n};\n",[103],[563],{"type":13,"tag":106,"props":564,"children":565},{"__ignoreMap":5},[566],{"type":19,"value":560},{"type":13,"tag":98,"props":568,"children":571},{"code":569,"language":101,"meta":5,"className":570},"// ./main.js\nimport postChunk from './PostChunk.mjs';\n\ncontainer.getPostProcessor().addChunk(postChunk);\n",[103],[572],{"type":13,"tag":106,"props":573,"children":574},{"__ignoreMap":5},[575],{"type":19,"value":569},{"type":13,"tag":81,"props":577,"children":579},{"id":578},"resume",[580],{"type":19,"value":581},"Resume",{"type":13,"tag":21,"props":583,"children":584},{},[585,589],{"type":13,"tag":106,"props":586,"children":587},{"className":5},[588],{"type":19,"value":7},{"type":19,"value":590}," offers Dependency Injection for regular JavaScript with minimal manual configuration, supporting both\nbrowser and Node.js environments. Its use of late binding and an object container in JavaScript applications, along with\nthe ability to modify the behavior of created objects (via pseudo-interfaces and wrappers), allows you to apply\narchitectural solutions from other languages (such as Java, PHP, C#) and fully harness the capabilities of npm packages\nand ES6 modules in JavaScript applications, particularly in the Node.js environment.",{"title":5,"searchDepth":592,"depth":592,"links":593},2,[594,595,596,597,598,599,600,605],{"id":83,"depth":592,"text":86},{"id":131,"depth":592,"text":134},{"id":178,"depth":592,"text":181},{"id":236,"depth":592,"text":239},{"id":284,"depth":592,"text":287},{"id":355,"depth":592,"text":358},{"id":418,"depth":592,"text":421,"children":601},[602,604],{"id":52,"depth":603,"text":451},3,{"id":59,"depth":603,"text":461},{"id":578,"depth":592,"text":581},"markdown","content:index.md","content","index.md","md",1697116041303]