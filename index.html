<!DOCTYPE html>
<html >
<head><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>@teqfw&#x2F;di</title>
<link rel="icon" type="image/x-icon" href="/favicon.ico">
<meta property="og:title" content="@teqfw/di">
<meta name="description" content="A Dependency Injection container for regular JavaScript is provided, which can be used in both browser and Node.js
applications. This library exclusively supports ES6 modules. The primary objective of this library is late binding with
minimal manual configuration for the container. All linking instructions are encapsulated within the dependency
identifiers and source path resolver. Additionally, the container offers the capability to modify object identifiers
(preprocessing) and the created objects (postprocessing). These features enable you to more comprehensively
distribute the necessary functionality across npm packages and reuse npm packages in different projects, following a
'modular monolith' architecture (see the sample).">
<meta property="og:description" content="A Dependency Injection container for regular JavaScript is provided, which can be used in both browser and Node.js
applications. This library exclusively supports ES6 modules. The primary objective of this library is late binding with
minimal manual configuration for the container. All linking instructions are encapsulated within the dependency
identifiers and source path resolver. Additionally, the container offers the capability to modify object identifiers
(preprocessing) and the created objects (postprocessing). These features enable you to more comprehensively
distribute the necessary functionality across npm packages and reuse npm packages in different projects, following a
'modular monolith' architecture (see the sample).">
<style>HEADER{background-color:var(--color-set-black);color:var(--color-set-green);position:sticky;top:0;z-index:1000}.h-center,.h-left,.h-right,HEADER{align-items:center;display:flex;justify-content:space-between}HEADER H3,HEADER H4{margin-block:10px 10px}.h-left{margin-left:20px}.h-right{margin-right:20px}.img-container{border-radius:50%;height:40px;margin:5px;overflow:hidden;width:40px}.img-container IMG{height:100%;-o-object-fit:cover;object-fit:cover;width:100%}@media only screen and (max-width:800px){.h-center H3{display:none}}</style>
<style>FOOTER{align-items:center;background-color:var(--color-set-black);display:flex;justify-content:center;margin-top:50px;padding:5px;text-align:center;z-index:1000}FOOTER,FOOTER A{color:var(--color-set-green)}FOOTER A{font-weight:400}FOOTER .v-line{padding-left:5px;padding-right:5px}@media only screen and (max-width:800px){FOOTER{flex-direction:column}FOOTER .v-line{display:none}}</style>
<style>.app-frame{flex-direction:column;min-height:100vh}.app-frame,.app-main{display:flex}.app-center,.app-left,.app-right{flex:1}.app-center{margin:0;max-width:800px;padding-left:5px;padding-right:5px}.app-center IMG{width:100%}@media only screen and (max-width:800px){.app-center,PRE{max-width:calc(100vw - 10px)}}</style>
<style>pre code .line{display:block;min-height:1rem}</style>
<style>:root{--color-set-black:#16181f;--color-set-green:#07b469}HTML{font-family:Inter,sans-serif;offset-anchor:1cm 2cm}BODY{font-size:1rem;margin:0;padding:0}H1{font-size:2.25rem}H2{font-size:1.5rem}H3{font-size:1.25rem}H4{font-size:1rem}A{color:#0a9466;font-weight:700}A,A:visited{text-decoration:none}P{text-align:justify}PRE{background-color:var(--color-set-black);color:var(--color-set-green);font-size:.75rem;padding:5px}</style>
<style>@font-face{font-display:swap;font-family:Inter;font-style:normal;font-weight:400;src:url(/_nuxt/Inter-400-1.9508ee6d.woff2) format("woff2");unicode-range:u+0460-052f,u+1c80-1c88,u+20b4,u+2de0-2dff,u+a640-a69f,u+fe2e-fe2f}@font-face{font-display:swap;font-family:Inter;font-style:normal;font-weight:400;src:url(/_nuxt/Inter-400-2.b75a5bf9.woff2) format("woff2");unicode-range:u+0301,u+0400-045f,u+0490-0491,u+04b0-04b1,u+2116}@font-face{font-display:swap;font-family:Inter;font-style:normal;font-weight:400;src:url(/_nuxt/Inter-400-3.6888cfd9.woff2) format("woff2");unicode-range:u+1f??}@font-face{font-display:swap;font-family:Inter;font-style:normal;font-weight:400;src:url(/_nuxt/Inter-400-4.4d906204.woff2) format("woff2");unicode-range:u+0370-03ff}@font-face{font-display:swap;font-family:Inter;font-style:normal;font-weight:400;src:url(/_nuxt/Inter-400-5.9fd231a7.woff2) format("woff2");unicode-range:u+0102-0103,u+0110-0111,u+0128-0129,u+0168-0169,u+01a0-01a1,u+01af-01b0,u+0300-0301,u+0303-0304,u+0308-0309,u+0323,u+0329,u+1ea0-1ef9,u+20ab}@font-face{font-display:swap;font-family:Inter;font-style:normal;font-weight:400;src:url(/_nuxt/Inter-400-6.56d25f40.woff2) format("woff2");unicode-range:u+0100-02af,u+0304,u+0308,u+0329,u+1e00-1e9f,u+1ef2-1eff,u+2020,u+20a0-20ab,u+20ad-20cf,u+2113,u+2c60-2c7f,u+a720-a7ff}@font-face{font-display:swap;font-family:Inter;font-style:normal;font-weight:400;src:url(/_nuxt/Inter-400-7.2301bb03.woff2) format("woff2");unicode-range:u+00??,u+0131,u+0152-0153,u+02bb-02bc,u+02c6,u+02da,u+02dc,u+0304,u+0308,u+0329,u+2000-206f,u+2074,u+20ac,u+2122,u+2191,u+2193,u+2212,u+2215,u+feff,u+fffd}</style>
<link rel="stylesheet" href="/_nuxt/ProsePre.e63e49c6.css">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/entry.73467ad7.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/default.bf8a8d68.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/index.bc54e65e.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/ContentDoc.e4f71e3e.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/ContentRenderer.9fef244b.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/ContentRendererMarkdown.vue.07a9213d.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/index.288f722b.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/preview.7f453a91.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/ContentQuery.a72e6a8b.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/query.98004ed5.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/ContentRendererMarkdown.ee78132c.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseH1.f1555e6f.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseP.58adcdc5.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseEm.ac568d07.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseA.a45e0783.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/nuxt-link.8327fc1f.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseH2.fda15a79.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProsePre.3a16fa38.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseCode.vue.fd1b2627.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseCode.07f41f46.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseCodeInline.624f7074.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseUl.2394cb93.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseLi.dc39a7a6.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseStrong.43f3fdd5.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseImg.04c6528a.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseH3.5f1ab195.js">
<link rel="prefetch" as="script" crossorigin href="/_nuxt/error-404.f9fa3cf3.js">
<link rel="prefetch" as="script" crossorigin href="/_nuxt/error-500.b74218cf.js">
<script type="module" src="/_nuxt/entry.73467ad7.js" crossorigin></script></head>
<body ><div id="__nuxt"><div class="app-frame"><header><div class="h-left"><div class="img-container"><img src="/favicon.ico" alt="logo"></div><h4>TeqFW</h4></div><div class="h-center"><h3>Dependency Injection</h3></div><div class="h-right"><div class="img-container"><a href="https://www.npmjs.com/package/@teqfw/di"><img src="/img/npm.png" alt="npm"></a></div><div class="img-container"><a href="https://github.com/teqfw/di"><img src="/img/github.svg" alt="GitHub"></a></div></div></header><div class="app-main"><div class="app-left"></div><main class="app-center"><!--[--><!--[--><div><h1 id="teqfwdi"><!--[-->@teqfw/di<!--]--></h1><p><!--[-->A Dependency Injection container for regular JavaScript is provided, which can be used in both <em><!--[-->browser<!--]--></em> and <em><!--[-->Node.js<!--]--></em>
applications. This library exclusively supports ES6 modules. The primary objective of this library is late binding with
<em><!--[-->minimal manual configuration<!--]--></em> for the container. All linking instructions are encapsulated within the dependency
identifiers and source path resolver. Additionally, the container offers the capability to modify object identifiers
(<em><!--[-->preprocessing<!--]--></em>) and the created objects (<em><!--[-->postprocessing<!--]--></em>). These features enable you to more comprehensively
distribute the necessary functionality across npm packages and reuse npm packages in different projects, following a
&#39;<em><!--[-->modular monolith<!--]--></em>&#39; architecture (see the <a href="https://github.com/flancer64/demo-di-app" rel="nofollow"><!--[-->sample<!--]--></a>).<!--]--></p><h2 id="inversion-of-control"><a href="#inversion-of-control"><!--[-->Inversion of Control<!--]--></a></h2><p><!--[-->The primary motivation for creating this library was the concept that JavaScript is a language in which the entire
application can be written, both on the front end and the back end. The idea was to enable the use of the same
JavaScript code seamlessly on both the front end and the back end without requiring any changes, including additional
transpilation.<!--]--></p><p><!--[-->The main challenge encountered along this path was static importing. When the entire application can fit into a single
npm package, all sources can be linked to each other through relative paths. However, if the sources are distributed
across different npm packages, addressing them becomes problematic:<!--]--></p><!--[--><pre class="language-javascript" style=""><!--[--><code>// backend style
import something from &#39;@vendor/package/src/Module.js&#39;;

// frontend style
import something from &#39;https://domain.com/@vendor/package/src/Module.js&#39;; 
</code><!--]--></pre><!--]--><p><!--[-->The inversion of control (IoC) design pattern came to the rescue. In this pattern, any software object with external
dependencies provides a mechanism for obtaining these dependencies. The external environment, whether it&#39;s a test unit
or an object container, is responsible for creating these dependencies and providing them to the software object.<!--]--></p><!--[--><pre class="language-javascript" style=""><!--[--><code>// constructor-based injection
class Service {
  constructor(config, logger) {}
}
</code><!--]--></pre><!--]--><p><!--[-->If all dependencies are added to software objects through a similar mechanism, there is no need to use static imports in
the source code itself. Now, they can be used without any changes, both on the front end and on the back end.<!--]--></p><h2 id="object-container"><a href="#object-container"><!--[-->Object Container<!--]--></a></h2><p><!--[-->Many programming languages implement the Dependency Injection pattern. In this pattern, an application typically
utilizes an object container, responsible for creating all the application&#39;s objects and their dependencies. The
<code class=""><!--[-->@teqfw/di<!--]--></code> package provides precisely such an object container (<code class=""><!--[-->src/Container.js<!--]--></code>). This object container is
initialized and configured at the outset of application execution, after which it assumes responsibility for creating
the remaining application objects:<!--]--></p><!--[--><pre class="language-javascript" style=""><!--[--><code>import Container from &#39;@teqfw/di&#39;;

const container = new Container();
const resolver = container.getResolver();
resolver.addNamespaceRoot(&#39;App_&#39;, pathApp);
resolver.addNamespaceRoot(&#39;Sample_Lib_&#39;, pathLib);
const app = await container.get(&#39;App_Main$&#39;);
</code><!--]--></pre><!--]--><p><!--[-->Since JavaScript does not have its own namespaces, similar to packages in Java and namespaces in PHP, the experience of
<a href="https://framework.zend.com/manual/2.4/en/migration/namespacing-old-classes.html" rel="nofollow"><!--[-->Zend 1<!--]--></a> is used as the basis for
identifiers.<!--]--></p><h2 id="namespaces"><a href="#namespaces"><!--[-->Namespaces<!--]--></a></h2><p><!--[-->The primary purpose of namespaces is to address code elements within an application. In JavaScript (JS) applications,
code is organized into npm packages, within which the sources reside in files and directories. Each npm package and its
root directory can be linked to a namespace:<!--]--></p><!--[--><pre class="" style=""><!--[--><code>Vendor_Package_ =&gt; /home/user/app/node_modules/@vendor/package/src/....
</code><!--]--></pre><!--]--><p><!--[-->This way, you can reference any ES6 module in any npm package:<!--]--></p><!--[--><pre class="" style=""><!--[--><code>Venodr_Package_Shared_Dto_Service_Save 
    =&gt; /home/user/app/node_modules/@vendor/package/src/Shared/Dto/Service/Save.js 
</code><!--]--></pre><!--]--><p><!--[-->Depending on the execution environment, the mapping may be different:<!--]--></p><!--[--><pre class="" style=""><!--[--><code>Vendor_Package_ =&gt; /home/user/app/node_modules/@vendor/package/src    // Linux style
Vendor_Package_ =&gt; C:\projects\app\node_modules\@vendor\package\src   // Windows style
Vendor_Package_ =&gt; https://unpkg.com/@vendor/package/src              // Web style
</code><!--]--></pre><!--]--><p><!--[-->The source code employs namespaces to reference dependencies, while the object container utilizes a resolver to
translate the namespace into the corresponding path to the source code file, contingent upon the runtime environment:<!--]--></p><!--[--><pre class="" style=""><!--[--><code>Venodr_Package_Shared_Dto_Service_Save 
    =&gt; /home/user/app/node_modules/@vendor/package/src/Shared/Dto/Service/Save.js
Venodr_Package_Shared_Dto_Service_Save 
    =&gt; C:\projects\app\node_modules\@vendor\package\src\Shared\Dto\Service\Save.js
Venodr_Package_Shared_Dto_Service_Save 
    =&gt; https://unpkg.com/@vendor/package/src/Shared/Dto/Service/Save.js
</code><!--]--></pre><!--]--><h2 id="dependency-specification"><a href="#dependency-specification"><!--[-->Dependency Specification<!--]--></a></h2><p><!--[-->JavaScript lacks reflection capabilities similar to Java or PHP. Consequently, to enable the object container to
comprehend the necessary dependencies for creating a specific object, a distinct convention is employed - a dependency
specification. A dependency specification is an object where each key represents the identifier of the required
dependency:<!--]--></p><!--[--><pre class="language-javascript" style=""><!--[--><code>class Service {
  constructor(
          {
            App_Config: config,
            App_Logger: logger
          }
  ) {}
}
</code><!--]--></pre><!--]--><p><!--[-->In the object container, the required object is created as follows:<!--]--></p><!--[--><pre class="language-javascript" style=""><!--[--><code>const App_Config = await container.get(&#39;App_Config&#39;);
const App_Logger = await container.get(&#39;App_Logger&#39;);
const spec = {App_Config, App_Logger};
const obj = new Service(spec);
</code><!--]--></pre><!--]--><p><!--[-->If dependencies are injected into a factory function, it appears as follows:<!--]--></p><!--[--><pre class="language-javascript" style=""><!--[--><code>function Factory({App_Config: config, App_Logger: logger}) {
  // perform operations with dependencies and compose the result
  return res;
}
</code><!--]--></pre><!--]--><h2 id="es6-export"><a href="#es6-export"><!--[-->Es6 export<!--]--></a></h2><p><!--[-->In ES6+, a distinct building block in application development is the act
of <a href="https://flancer32.com/es6-export-as-code-brick-b33a8efb3510" rel="nofollow"><!--[-->exporting<!--]--></a>:<!--]--></p><!--[--><pre class="language-javascript" style=""><!--[--><code>export {
  obj1 as default, obj2, obj3
};
</code><!--]--></pre><!--]--><p><!--[-->Static linking through imports is performed at the level of these building blocks:<!--]--></p><!--[--><pre class="language-javascript" style=""><!--[--><code>import obj1 from &#39;./mod.js&#39;;
import {obj2} from &#39;./mod.js&#39;;
</code><!--]--></pre><!--]--><p><!--[-->This implies that the dependency identifier must have the capability to reference not only the ES6 module itself but
also a specific export within it, as illustrated in this example:<!--]--></p><!--[--><pre class="language-javascript" style=""><!--[--><code>const exp = &#39;Vendor_Package_Module.export&#39;;
const def = &#39;Vendor_Package_Module.default&#39;;
const obj2 = &#39;Vendor_Package_Module.obj2&#39;;
</code><!--]--></pre><!--]--><p><!--[-->In this case, the dependency declaration in a constructor or factory function could look like this:<!--]--></p><!--[--><pre class="language-javascript" style=""><!--[--><code>class Service {
  constructor(
          {
            &#39;App_Config.default&#39;: config,
            &#39;App_Util.logger&#39;: logger
          }
  ) {}
}
</code><!--]--></pre><!--]--><h2 id="late-binding"><a href="#late-binding"><!--[-->Late binding<!--]--></a></h2><p><!--[-->The object container links objects not at the source code level but in runtime mode. In my applications, I have
encountered two particularly useful runtime object lifecycles:<!--]--></p><ul><!--[--><li><!--[--><strong><!--[-->Singleton<!--]--></strong>: It exists in a single instance within the application.<!--]--></li><li><!--[--><strong><!--[-->Instance<!--]--></strong>: A new object is created each time.<!--]--></li><!--]--></ul><p><!--[-->Since any string can be used as an object key in a dependency specification, various formats can be devised to specify
the lifecycle of the required dependency. I have personally chosen the following format:<!--]--></p><!--[--><pre class="language-javascript" style=""><!--[--><code>const asIs = &#39;Vendor_Package_Module.default&#39;;
const asSingleton = &#39;Vendor_Package_Module.default$&#39;;
const asInstance = &#39;Vendor_Package_Module.default$$&#39;;
</code><!--]--></pre><!--]--><p><!--[-->In principle, each package can have its own format for describing the dependencies it uses internally. The
<code class=""><!--[-->TeqFw_Di_Container_Parser<!--]--></code> object is responsible for applying the appropriate format within the required namespace.<!--]--></p><h2 id="transforming-the-result"><a href="#transforming-the-result"><!--[-->Transforming the Result<!--]--></a></h2><p><!--[-->Here are the steps for the object container:<!--]--></p><p><!--[--><img src="./img/teqfw_di_container_steps.png" alt="processing steps"><!--]--></p><p><!--[-->There are two stages involved here:<!--]--></p><ul><!--[--><li><!--[--><strong><!--[-->Preprocessing<!--]--></strong>: the modification of the dependency identifier<!--]--></li><li><!--[--><strong><!--[-->Postprocessing<!--]--></strong>: the modification of the created object<!--]--></li><!--]--></ul><h3 id="preprocessing"><a href="#preprocessing"><!--[-->Preprocessing<!--]--></a></h3><p><!--[-->At times, situations may arise, especially when utilizing various extensions of the core functionality, where it becomes
necessary to redefine certain objects within the application. For such scenarios, <code class=""><!--[-->@teqfw/di<!--]--></code> includes a preprocessor:<!--]--></p><!--[--><pre class="language-javascript" style=""><!--[--><code>/** @type {TeqFw_Di_Api_Container_PreProcessor} */
const pre = container.getPreProcessor();
</code><!--]--></pre><!--]--><p><!--[-->You can add handlers (chunks) to the preprocessor that are capable of modifying the initial <code class=""><!--[-->depId<!--]--></code>:<!--]--></p><!--[--><pre class="language-javascript" style=""><!--[--><code>/** @type {TeqFw_Di_Api_Container_PreProcessor_Chunk} */
const replace = new ReplaceChunk(); // some implementation of the interface
pre.addChunk(replace);
</code><!--]--></pre><!--]--><p><!--[-->The preprocessor calls the handlers sequentially and can, for example, replace a dependency from the base npm package
(<code class=""><!--[-->App_Base_Mod_Api_Service_Auth<!--]--></code>) with another dependency from one of the npm packages (<code class=""><!--[-->Auth_Password_Mod_Service<!--]--></code> or
<code class=""><!--[-->OAuth2_Mod_Service<!--]--></code>), depending on the npm packages included in the application compilation.<!--]--></p><p><!--[-->By using such replacements, you can implement the core functionality in one npm package, while in other npm packages,
you can implement the additional functionality required by the core package.<!--]--></p><h3 id="postprocessing"><a href="#postprocessing"><!--[-->Postprocessing<!--]--></a></h3><p><!--[-->Since the container creates all objects in the application, it can also perform additional actions on newly created
objects, such as adding extra functionality to them in the form of a wrapper.<!--]--></p><p><!--[--><code class=""><!--[-->@teqfw/di<!--]--></code> enables you to add individual handlers to the post-processing stage and modify the result. For example, you
can wrap a finished object or perform various operations on it:<!--]--></p><!--[--><pre class="language-javascript" style=""><!--[--><code>// ./PostChunk.js
/**
 * @implements TeqFw_Di_Api_Container_PostProcessor_Chunk
 */
export default {
    modify: function (obj, originalId, stack) {
        if (originalId.wrappers.indexOf(&#39;proxy&#39;) !== -1)
            return new Proxy(obj, {
                get: async function (base, name) { /* do something */ }
            });
        else return obj;
    }
};
</code><!--]--></pre><!--]--><!--[--><pre class="language-javascript" style=""><!--[--><code>// ./main.js
import postChunk from &#39;./PostChunk.mjs&#39;;

container.getPostProcessor().addChunk(postChunk);
</code><!--]--></pre><!--]--><h2 id="resume"><a href="#resume"><!--[-->Resume<!--]--></a></h2><p><!--[--><code class=""><!--[-->@teqfw/di<!--]--></code> offers Dependency Injection for regular JavaScript with minimal manual configuration, supporting both
browser and Node.js environments. Its use of late binding and an object container in JavaScript applications, along with
the ability to modify the behavior of created objects (via pseudo-interfaces and wrappers), allows you to apply
architectural solutions from other languages (such as Java, PHP, C#) and fully harness the capabilities of npm packages
and ES6 modules in JavaScript applications, particularly in the Node.js environment.<!--]--></p></div><!--]--><!--]--></main><div class="app-right"></div></div><footer><div>© 2023 Wiredgeese</div><div class="v-line">|</div><div><a href="mailto:info@wiredgeese.com">info@wiredgeese.com</a></div><div class="v-line">|</div><div><a href="https://t.me/wiredgeese">@wiredgeese</a></div></footer></div></div><script type="application/json" id="__NUXT_DATA__" data-ssr="true">[["Reactive",1],{"data":2,"state":611,"_errors":612,"serverRendered":614,"path":4,"prerenderedAt":615},{"content-query-1DxZ1vYQk5":3},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":5,"title":7,"description":8,"body":9,"_type":606,"_id":607,"_source":608,"_file":609,"_extension":610},"/","",false,"@teqfw/di","A Dependency Injection container for regular JavaScript is provided, which can be used in both browser and Node.js\napplications. This library exclusively supports ES6 modules. The primary objective of this library is late binding with\nminimal manual configuration for the container. All linking instructions are encapsulated within the dependency\nidentifiers and source path resolver. Additionally, the container offers the capability to modify object identifiers\n(preprocessing) and the created objects (postprocessing). These features enable you to more comprehensively\ndistribute the necessary functionality across npm packages and reuse npm packages in different projects, following a\n'modular monolith' architecture (see the sample).",{"type":10,"children":11,"toc":591},"root",[12,20,80,87,92,97,110,115,124,129,135,153,162,176,182,187,195,200,208,213,221,226,234,240,245,254,259,268,273,282,288,302,311,316,325,330,339,344,353,359,364,390,395,404,416,422,427,436,441,464,469,480,489,500,509,535,540,544,549,558,567,576,582],{"type":13,"tag":14,"props":15,"children":17},"element","h1",{"id":16},"teqfwdi",[18],{"type":19,"value":7},"text",{"type":13,"tag":21,"props":22,"children":23},"p",{},[24,26,32,34,39,41,46,48,53,55,60,62,67,69,78],{"type":19,"value":25},"A Dependency Injection container for regular JavaScript is provided, which can be used in both ",{"type":13,"tag":27,"props":28,"children":29},"em",{},[30],{"type":19,"value":31},"browser",{"type":19,"value":33}," and ",{"type":13,"tag":27,"props":35,"children":36},{},[37],{"type":19,"value":38},"Node.js",{"type":19,"value":40},"\napplications. This library exclusively supports ES6 modules. The primary objective of this library is late binding with\n",{"type":13,"tag":27,"props":42,"children":43},{},[44],{"type":19,"value":45},"minimal manual configuration",{"type":19,"value":47}," for the container. All linking instructions are encapsulated within the dependency\nidentifiers and source path resolver. Additionally, the container offers the capability to modify object identifiers\n(",{"type":13,"tag":27,"props":49,"children":50},{},[51],{"type":19,"value":52},"preprocessing",{"type":19,"value":54},") and the created objects (",{"type":13,"tag":27,"props":56,"children":57},{},[58],{"type":19,"value":59},"postprocessing",{"type":19,"value":61},"). These features enable you to more comprehensively\ndistribute the necessary functionality across npm packages and reuse npm packages in different projects, following a\n'",{"type":13,"tag":27,"props":63,"children":64},{},[65],{"type":19,"value":66},"modular monolith",{"type":19,"value":68},"' architecture (see the ",{"type":13,"tag":70,"props":71,"children":75},"a",{"href":72,"rel":73},"https://github.com/flancer64/demo-di-app",[74],"nofollow",[76],{"type":19,"value":77},"sample",{"type":19,"value":79},").",{"type":13,"tag":81,"props":82,"children":84},"h2",{"id":83},"inversion-of-control",[85],{"type":19,"value":86},"Inversion of Control",{"type":13,"tag":21,"props":88,"children":89},{},[90],{"type":19,"value":91},"The primary motivation for creating this library was the concept that JavaScript is a language in which the entire\napplication can be written, both on the front end and the back end. The idea was to enable the use of the same\nJavaScript code seamlessly on both the front end and the back end without requiring any changes, including additional\ntranspilation.",{"type":13,"tag":21,"props":93,"children":94},{},[95],{"type":19,"value":96},"The main challenge encountered along this path was static importing. When the entire application can fit into a single\nnpm package, all sources can be linked to each other through relative paths. However, if the sources are distributed\nacross different npm packages, addressing them becomes problematic:",{"type":13,"tag":98,"props":99,"children":104},"pre",{"code":100,"language":101,"meta":5,"className":102},"// backend style\nimport something from '@vendor/package/src/Module.js';\n\n// frontend style\nimport something from 'https://domain.com/@vendor/package/src/Module.js'; \n","javascript",[103],"language-javascript",[105],{"type":13,"tag":106,"props":107,"children":108},"code",{"__ignoreMap":5},[109],{"type":19,"value":100},{"type":13,"tag":21,"props":111,"children":112},{},[113],{"type":19,"value":114},"The inversion of control (IoC) design pattern came to the rescue. In this pattern, any software object with external\ndependencies provides a mechanism for obtaining these dependencies. The external environment, whether it's a test unit\nor an object container, is responsible for creating these dependencies and providing them to the software object.",{"type":13,"tag":98,"props":116,"children":119},{"code":117,"language":101,"meta":5,"className":118},"// constructor-based injection\nclass Service {\n  constructor(config, logger) {}\n}\n",[103],[120],{"type":13,"tag":106,"props":121,"children":122},{"__ignoreMap":5},[123],{"type":19,"value":117},{"type":13,"tag":21,"props":125,"children":126},{},[127],{"type":19,"value":128},"If all dependencies are added to software objects through a similar mechanism, there is no need to use static imports in\nthe source code itself. Now, they can be used without any changes, both on the front end and on the back end.",{"type":13,"tag":81,"props":130,"children":132},{"id":131},"object-container",[133],{"type":19,"value":134},"Object Container",{"type":13,"tag":21,"props":136,"children":137},{},[138,140,144,146,151],{"type":19,"value":139},"Many programming languages implement the Dependency Injection pattern. In this pattern, an application typically\nutilizes an object container, responsible for creating all the application's objects and their dependencies. The\n",{"type":13,"tag":106,"props":141,"children":142},{"className":5},[143],{"type":19,"value":7},{"type":19,"value":145}," package provides precisely such an object container (",{"type":13,"tag":106,"props":147,"children":148},{"className":5},[149],{"type":19,"value":150},"src/Container.js",{"type":19,"value":152},"). This object container is\ninitialized and configured at the outset of application execution, after which it assumes responsibility for creating\nthe remaining application objects:",{"type":13,"tag":98,"props":154,"children":157},{"code":155,"language":101,"meta":5,"className":156},"import Container from '@teqfw/di';\n\nconst container = new Container();\nconst resolver = container.getResolver();\nresolver.addNamespaceRoot('App_', pathApp);\nresolver.addNamespaceRoot('Sample_Lib_', pathLib);\nconst app = await container.get('App_Main$');\n",[103],[158],{"type":13,"tag":106,"props":159,"children":160},{"__ignoreMap":5},[161],{"type":19,"value":155},{"type":13,"tag":21,"props":163,"children":164},{},[165,167,174],{"type":19,"value":166},"Since JavaScript does not have its own namespaces, similar to packages in Java and namespaces in PHP, the experience of\n",{"type":13,"tag":70,"props":168,"children":171},{"href":169,"rel":170},"https://framework.zend.com/manual/2.4/en/migration/namespacing-old-classes.html",[74],[172],{"type":19,"value":173},"Zend 1",{"type":19,"value":175}," is used as the basis for\nidentifiers.",{"type":13,"tag":81,"props":177,"children":179},{"id":178},"namespaces",[180],{"type":19,"value":181},"Namespaces",{"type":13,"tag":21,"props":183,"children":184},{},[185],{"type":19,"value":186},"The primary purpose of namespaces is to address code elements within an application. In JavaScript (JS) applications,\ncode is organized into npm packages, within which the sources reside in files and directories. Each npm package and its\nroot directory can be linked to a namespace:",{"type":13,"tag":98,"props":188,"children":190},{"code":189},"Vendor_Package_ => /home/user/app/node_modules/@vendor/package/src/....\n",[191],{"type":13,"tag":106,"props":192,"children":193},{"__ignoreMap":5},[194],{"type":19,"value":189},{"type":13,"tag":21,"props":196,"children":197},{},[198],{"type":19,"value":199},"This way, you can reference any ES6 module in any npm package:",{"type":13,"tag":98,"props":201,"children":203},{"code":202},"Venodr_Package_Shared_Dto_Service_Save \n    => /home/user/app/node_modules/@vendor/package/src/Shared/Dto/Service/Save.js \n",[204],{"type":13,"tag":106,"props":205,"children":206},{"__ignoreMap":5},[207],{"type":19,"value":202},{"type":13,"tag":21,"props":209,"children":210},{},[211],{"type":19,"value":212},"Depending on the execution environment, the mapping may be different:",{"type":13,"tag":98,"props":214,"children":216},{"code":215},"Vendor_Package_ => /home/user/app/node_modules/@vendor/package/src    // Linux style\nVendor_Package_ => C:\\projects\\app\\node_modules\\@vendor\\package\\src   // Windows style\nVendor_Package_ => https://unpkg.com/@vendor/package/src              // Web style\n",[217],{"type":13,"tag":106,"props":218,"children":219},{"__ignoreMap":5},[220],{"type":19,"value":215},{"type":13,"tag":21,"props":222,"children":223},{},[224],{"type":19,"value":225},"The source code employs namespaces to reference dependencies, while the object container utilizes a resolver to\ntranslate the namespace into the corresponding path to the source code file, contingent upon the runtime environment:",{"type":13,"tag":98,"props":227,"children":229},{"code":228},"Venodr_Package_Shared_Dto_Service_Save \n    => /home/user/app/node_modules/@vendor/package/src/Shared/Dto/Service/Save.js\nVenodr_Package_Shared_Dto_Service_Save \n    => C:\\projects\\app\\node_modules\\@vendor\\package\\src\\Shared\\Dto\\Service\\Save.js\nVenodr_Package_Shared_Dto_Service_Save \n    => https://unpkg.com/@vendor/package/src/Shared/Dto/Service/Save.js\n",[230],{"type":13,"tag":106,"props":231,"children":232},{"__ignoreMap":5},[233],{"type":19,"value":228},{"type":13,"tag":81,"props":235,"children":237},{"id":236},"dependency-specification",[238],{"type":19,"value":239},"Dependency Specification",{"type":13,"tag":21,"props":241,"children":242},{},[243],{"type":19,"value":244},"JavaScript lacks reflection capabilities similar to Java or PHP. Consequently, to enable the object container to\ncomprehend the necessary dependencies for creating a specific object, a distinct convention is employed - a dependency\nspecification. A dependency specification is an object where each key represents the identifier of the required\ndependency:",{"type":13,"tag":98,"props":246,"children":249},{"code":247,"language":101,"meta":5,"className":248},"class Service {\n  constructor(\n          {\n            App_Config: config,\n            App_Logger: logger\n          }\n  ) {}\n}\n",[103],[250],{"type":13,"tag":106,"props":251,"children":252},{"__ignoreMap":5},[253],{"type":19,"value":247},{"type":13,"tag":21,"props":255,"children":256},{},[257],{"type":19,"value":258},"In the object container, the required object is created as follows:",{"type":13,"tag":98,"props":260,"children":263},{"code":261,"language":101,"meta":5,"className":262},"const App_Config = await container.get('App_Config');\nconst App_Logger = await container.get('App_Logger');\nconst spec = {App_Config, App_Logger};\nconst obj = new Service(spec);\n",[103],[264],{"type":13,"tag":106,"props":265,"children":266},{"__ignoreMap":5},[267],{"type":19,"value":261},{"type":13,"tag":21,"props":269,"children":270},{},[271],{"type":19,"value":272},"If dependencies are injected into a factory function, it appears as follows:",{"type":13,"tag":98,"props":274,"children":277},{"code":275,"language":101,"meta":5,"className":276},"function Factory({App_Config: config, App_Logger: logger}) {\n  // perform operations with dependencies and compose the result\n  return res;\n}\n",[103],[278],{"type":13,"tag":106,"props":279,"children":280},{"__ignoreMap":5},[281],{"type":19,"value":275},{"type":13,"tag":81,"props":283,"children":285},{"id":284},"es6-export",[286],{"type":19,"value":287},"Es6 export",{"type":13,"tag":21,"props":289,"children":290},{},[291,293,300],{"type":19,"value":292},"In ES6+, a distinct building block in application development is the act\nof ",{"type":13,"tag":70,"props":294,"children":297},{"href":295,"rel":296},"https://flancer32.com/es6-export-as-code-brick-b33a8efb3510",[74],[298],{"type":19,"value":299},"exporting",{"type":19,"value":301},":",{"type":13,"tag":98,"props":303,"children":306},{"code":304,"language":101,"meta":5,"className":305},"export {\n  obj1 as default, obj2, obj3\n};\n",[103],[307],{"type":13,"tag":106,"props":308,"children":309},{"__ignoreMap":5},[310],{"type":19,"value":304},{"type":13,"tag":21,"props":312,"children":313},{},[314],{"type":19,"value":315},"Static linking through imports is performed at the level of these building blocks:",{"type":13,"tag":98,"props":317,"children":320},{"code":318,"language":101,"meta":5,"className":319},"import obj1 from './mod.js';\nimport {obj2} from './mod.js';\n",[103],[321],{"type":13,"tag":106,"props":322,"children":323},{"__ignoreMap":5},[324],{"type":19,"value":318},{"type":13,"tag":21,"props":326,"children":327},{},[328],{"type":19,"value":329},"This implies that the dependency identifier must have the capability to reference not only the ES6 module itself but\nalso a specific export within it, as illustrated in this example:",{"type":13,"tag":98,"props":331,"children":334},{"code":332,"language":101,"meta":5,"className":333},"const exp = 'Vendor_Package_Module.export';\nconst def = 'Vendor_Package_Module.default';\nconst obj2 = 'Vendor_Package_Module.obj2';\n",[103],[335],{"type":13,"tag":106,"props":336,"children":337},{"__ignoreMap":5},[338],{"type":19,"value":332},{"type":13,"tag":21,"props":340,"children":341},{},[342],{"type":19,"value":343},"In this case, the dependency declaration in a constructor or factory function could look like this:",{"type":13,"tag":98,"props":345,"children":348},{"code":346,"language":101,"meta":5,"className":347},"class Service {\n  constructor(\n          {\n            'App_Config.default': config,\n            'App_Util.logger': logger\n          }\n  ) {}\n}\n",[103],[349],{"type":13,"tag":106,"props":350,"children":351},{"__ignoreMap":5},[352],{"type":19,"value":346},{"type":13,"tag":81,"props":354,"children":356},{"id":355},"late-binding",[357],{"type":19,"value":358},"Late binding",{"type":13,"tag":21,"props":360,"children":361},{},[362],{"type":19,"value":363},"The object container links objects not at the source code level but in runtime mode. In my applications, I have\nencountered two particularly useful runtime object lifecycles:",{"type":13,"tag":365,"props":366,"children":367},"ul",{},[368,380],{"type":13,"tag":369,"props":370,"children":371},"li",{},[372,378],{"type":13,"tag":373,"props":374,"children":375},"strong",{},[376],{"type":19,"value":377},"Singleton",{"type":19,"value":379},": It exists in a single instance within the application.",{"type":13,"tag":369,"props":381,"children":382},{},[383,388],{"type":13,"tag":373,"props":384,"children":385},{},[386],{"type":19,"value":387},"Instance",{"type":19,"value":389},": A new object is created each time.",{"type":13,"tag":21,"props":391,"children":392},{},[393],{"type":19,"value":394},"Since any string can be used as an object key in a dependency specification, various formats can be devised to specify\nthe lifecycle of the required dependency. I have personally chosen the following format:",{"type":13,"tag":98,"props":396,"children":399},{"code":397,"language":101,"meta":5,"className":398},"const asIs = 'Vendor_Package_Module.default';\nconst asSingleton = 'Vendor_Package_Module.default$';\nconst asInstance = 'Vendor_Package_Module.default$$';\n",[103],[400],{"type":13,"tag":106,"props":401,"children":402},{"__ignoreMap":5},[403],{"type":19,"value":397},{"type":13,"tag":21,"props":405,"children":406},{},[407,409,414],{"type":19,"value":408},"In principle, each package can have its own format for describing the dependencies it uses internally. The\n",{"type":13,"tag":106,"props":410,"children":411},{"className":5},[412],{"type":19,"value":413},"TeqFw_Di_Container_Parser",{"type":19,"value":415}," object is responsible for applying the appropriate format within the required namespace.",{"type":13,"tag":81,"props":417,"children":419},{"id":418},"transforming-the-result",[420],{"type":19,"value":421},"Transforming the Result",{"type":13,"tag":21,"props":423,"children":424},{},[425],{"type":19,"value":426},"Here are the steps for the object container:",{"type":13,"tag":21,"props":428,"children":429},{},[430],{"type":13,"tag":431,"props":432,"children":435},"img",{"alt":433,"src":434},"processing steps","./img/teqfw_di_container_steps.png",[],{"type":13,"tag":21,"props":437,"children":438},{},[439],{"type":19,"value":440},"There are two stages involved here:",{"type":13,"tag":365,"props":442,"children":443},{},[444,454],{"type":13,"tag":369,"props":445,"children":446},{},[447,452],{"type":13,"tag":373,"props":448,"children":449},{},[450],{"type":19,"value":451},"Preprocessing",{"type":19,"value":453},": the modification of the dependency identifier",{"type":13,"tag":369,"props":455,"children":456},{},[457,462],{"type":13,"tag":373,"props":458,"children":459},{},[460],{"type":19,"value":461},"Postprocessing",{"type":19,"value":463},": the modification of the created object",{"type":13,"tag":465,"props":466,"children":467},"h3",{"id":52},[468],{"type":19,"value":451},{"type":13,"tag":21,"props":470,"children":471},{},[472,474,478],{"type":19,"value":473},"At times, situations may arise, especially when utilizing various extensions of the core functionality, where it becomes\nnecessary to redefine certain objects within the application. For such scenarios, ",{"type":13,"tag":106,"props":475,"children":476},{"className":5},[477],{"type":19,"value":7},{"type":19,"value":479}," includes a preprocessor:",{"type":13,"tag":98,"props":481,"children":484},{"code":482,"language":101,"meta":5,"className":483},"/** @type {TeqFw_Di_Api_Container_PreProcessor} */\nconst pre = container.getPreProcessor();\n",[103],[485],{"type":13,"tag":106,"props":486,"children":487},{"__ignoreMap":5},[488],{"type":19,"value":482},{"type":13,"tag":21,"props":490,"children":491},{},[492,494,499],{"type":19,"value":493},"You can add handlers (chunks) to the preprocessor that are capable of modifying the initial ",{"type":13,"tag":106,"props":495,"children":496},{"className":5},[497],{"type":19,"value":498},"depId",{"type":19,"value":301},{"type":13,"tag":98,"props":501,"children":504},{"code":502,"language":101,"meta":5,"className":503},"/** @type {TeqFw_Di_Api_Container_PreProcessor_Chunk} */\nconst replace = new ReplaceChunk(); // some implementation of the interface\npre.addChunk(replace);\n",[103],[505],{"type":13,"tag":106,"props":506,"children":507},{"__ignoreMap":5},[508],{"type":19,"value":502},{"type":13,"tag":21,"props":510,"children":511},{},[512,514,519,521,526,528,533],{"type":19,"value":513},"The preprocessor calls the handlers sequentially and can, for example, replace a dependency from the base npm package\n(",{"type":13,"tag":106,"props":515,"children":516},{"className":5},[517],{"type":19,"value":518},"App_Base_Mod_Api_Service_Auth",{"type":19,"value":520},") with another dependency from one of the npm packages (",{"type":13,"tag":106,"props":522,"children":523},{"className":5},[524],{"type":19,"value":525},"Auth_Password_Mod_Service",{"type":19,"value":527}," or\n",{"type":13,"tag":106,"props":529,"children":530},{"className":5},[531],{"type":19,"value":532},"OAuth2_Mod_Service",{"type":19,"value":534},"), depending on the npm packages included in the application compilation.",{"type":13,"tag":21,"props":536,"children":537},{},[538],{"type":19,"value":539},"By using such replacements, you can implement the core functionality in one npm package, while in other npm packages,\nyou can implement the additional functionality required by the core package.",{"type":13,"tag":465,"props":541,"children":542},{"id":59},[543],{"type":19,"value":461},{"type":13,"tag":21,"props":545,"children":546},{},[547],{"type":19,"value":548},"Since the container creates all objects in the application, it can also perform additional actions on newly created\nobjects, such as adding extra functionality to them in the form of a wrapper.",{"type":13,"tag":21,"props":550,"children":551},{},[552,556],{"type":13,"tag":106,"props":553,"children":554},{"className":5},[555],{"type":19,"value":7},{"type":19,"value":557}," enables you to add individual handlers to the post-processing stage and modify the result. For example, you\ncan wrap a finished object or perform various operations on it:",{"type":13,"tag":98,"props":559,"children":562},{"code":560,"language":101,"meta":5,"className":561},"// ./PostChunk.js\n/**\n * @implements TeqFw_Di_Api_Container_PostProcessor_Chunk\n */\nexport default {\n    modify: function (obj, originalId, stack) {\n        if (originalId.wrappers.indexOf('proxy') !== -1)\n            return new Proxy(obj, {\n                get: async function (base, name) { /* do something */ }\n            });\n        else return obj;\n    }\n};\n",[103],[563],{"type":13,"tag":106,"props":564,"children":565},{"__ignoreMap":5},[566],{"type":19,"value":560},{"type":13,"tag":98,"props":568,"children":571},{"code":569,"language":101,"meta":5,"className":570},"// ./main.js\nimport postChunk from './PostChunk.mjs';\n\ncontainer.getPostProcessor().addChunk(postChunk);\n",[103],[572],{"type":13,"tag":106,"props":573,"children":574},{"__ignoreMap":5},[575],{"type":19,"value":569},{"type":13,"tag":81,"props":577,"children":579},{"id":578},"resume",[580],{"type":19,"value":581},"Resume",{"type":13,"tag":21,"props":583,"children":584},{},[585,589],{"type":13,"tag":106,"props":586,"children":587},{"className":5},[588],{"type":19,"value":7},{"type":19,"value":590}," offers Dependency Injection for regular JavaScript with minimal manual configuration, supporting both\nbrowser and Node.js environments. Its use of late binding and an object container in JavaScript applications, along with\nthe ability to modify the behavior of created objects (via pseudo-interfaces and wrappers), allows you to apply\narchitectural solutions from other languages (such as Java, PHP, C#) and fully harness the capabilities of npm packages\nand ES6 modules in JavaScript applications, particularly in the Node.js environment.",{"title":5,"searchDepth":592,"depth":592,"links":593},2,[594,595,596,597,598,599,600,605],{"id":83,"depth":592,"text":86},{"id":131,"depth":592,"text":134},{"id":178,"depth":592,"text":181},{"id":236,"depth":592,"text":239},{"id":284,"depth":592,"text":287},{"id":355,"depth":592,"text":358},{"id":418,"depth":592,"text":421,"children":601},[602,604],{"id":52,"depth":603,"text":451},3,{"id":59,"depth":603,"text":461},{"id":578,"depth":592,"text":581},"markdown","content:index.md","content","index.md","md",{},{"content-query-1DxZ1vYQk5":613},null,true,1697353840006]</script>
<script>window.__NUXT__={};window.__NUXT__.config={public:{mdc:{components:{prose:true,map:{p:"prose-p",a:"prose-a",blockquote:"prose-blockquote","code-inline":"prose-code-inline",code:"ProseCodeInline",em:"prose-em",h1:"prose-h1",h2:"prose-h2",h3:"prose-h3",h4:"prose-h4",h5:"prose-h5",h6:"prose-h6",hr:"prose-hr",img:"prose-img",ul:"prose-ul",ol:"prose-ol",li:"prose-li",strong:"prose-strong",table:"prose-table",thead:"prose-thead",tbody:"prose-tbody",td:"prose-td",th:"prose-th",tr:"prose-tr"}},headings:{anchorLinks:{h1:false,h2:true,h3:true,h4:true,h5:false,h6:false}}},content:{locales:[],defaultLocale:"",integrity:1697353827627,experimental:{stripQueryParameters:false,advanceQuery:false,clientDB:false},respectPathCase:false,api:{baseURL:"/api/_content"},navigation:{fields:[]},tags:{p:"prose-p",a:"prose-a",blockquote:"prose-blockquote","code-inline":"prose-code-inline",code:"ProseCodeInline",em:"prose-em",h1:"prose-h1",h2:"prose-h2",h3:"prose-h3",h4:"prose-h4",h5:"prose-h5",h6:"prose-h6",hr:"prose-hr",img:"prose-img",ul:"prose-ul",ol:"prose-ol",li:"prose-li",strong:"prose-strong",table:"prose-table",thead:"prose-thead",tbody:"prose-tbody",td:"prose-td",th:"prose-th",tr:"prose-tr"},highlight:false,wsUrl:"",documentDriven:false,host:"",trailingSlash:false,contentHead:true,anchorLinks:{depth:4,exclude:[1]}},gtag:{id:"GTM-WGL4VX3N",config:{},initialConsent:true,loadingStrategy:"defer"}},app:{baseURL:"/",buildAssetsDir:"/_nuxt/",cdnURL:""}}</script></body>
</html>